#!/usr/bin/env python

import subprocess
import socket
import struct
import threading
import os
from dattolib import make_request_to_dattod
from request_pb2 import Request
from reply_pb2 import Reply

LISTEN_ADDRESS = ("0.0.0.0", 2856)

PASSOF_LIST = [Request.START_BACKUP, Request.STOP_BACKUP,
               Request.PAUSE_BACKUP, Request.RESUME_BACKUP,
               Request.BACKUP_STATUS]

def run_command(command):
    p = subprocess.Popen(command, stdout=subprocess.PIPE)
    (stdout, stderr) = p.communicate()
    return stdout.strip()

def get_basic_info():
    reply = Reply()
    reply.type = Reply.BASIC_INFO
    # TODO version
    reply.basic_info_reply.agent_version = "v2.0"
    reply.basic_info_reply.hostname = run_command(["hostname"])
    reply.basic_info_reply.uname_a = run_command(["uname", "-a"])
    reply.basic_info_reply.lsb_release_a = \
            run_command(["lsb_release", "-a"])

    return reply

def set_block_devices(reply):
    UUID_DIR = "/dev/disk/by-uuid/"
    for filename in os.listdir(UUID_DIR):
        device = reply.complete_info_reply.block_devices.add()
        # uuid
        device.uuid = filename
        real_relative_path = os.readlink(UUID_DIR + filename)
        # real_path
        device.real_path = \
                os.path.abspath(os.path.join(UUID_DIR, real_relative_path))

        block_dev_output = \
            run_command(["blockdev", "--getbsz", "--getsz", device.real_path])

        # block_size
        device.block_size = int(block_dev_output.splitlines()[0])
        # device_size
        device.device_size = int(block_dev_output.splitlines()[1]) * 512


        # Example of df -T:
        # # df -T /dev/sda1
        # Filesystem    Type   1K-blocks      Used Available Use% Mounted on
        # /dev/sda1     ext4   951636136  21644300 881651452   3% /
        #
        # TODO: This returns bad information for the mountpoint and fs
        #       when not run on the symlink
        df_output = run_command(["df", "-T", device.real_path])
        df_info_split = df_output.split("\n")[1].split()
        filesystem = df_info_split[1]
        used_size = int(df_info_split[3]) * 1024
        mount_location = df_info_split[6]

        # used_space
        device.used_space = used_size
        # file_system
        device.file_system = filesystem
        # mount_location
        device.mount_location = mount_location

def get_complete_info():
    reply = Reply()
    reply.type = Reply.COMPLETE_INFO
    # TODO version
    reply.complete_info_reply.agent_version = "v2.0"
    reply.complete_info_reply.hostname = run_command(["hostname"])
    reply.complete_info_reply.uname_a = run_command(["uname", "-a"])
    reply.complete_info_reply.lsb_release_a = \
            run_command(["lsb_release", "-a"])

    with open("/proc/meminfo") as meminfo:
        reply.complete_info_reply.meminfo = meminfo.read()

    with open("/proc/cpuinfo") as cpuinfo:
        reply.complete_info_reply.cpuinfo = cpuinfo.read()

    try:
        with open("/var/datto/dattod.pid") as datto_pid_file:
            dattod_pid = (datto_pid_file.read()).strip()

        with open("/proc/" + dattod_pid + "/stat") as dattod_stat:
            dattod_jiffs = int(dattod_stat.read().split()[21])

        jiffs_per_sec = int(run_command(["getconf", "CLK_TCK"]))
        
        # This is uptime from when the system booted
        dattod_uptime = dattod_jiffs / jiffs_per_sec

        with open("/proc/uptime") as uptime_file:
            system_uptime = int(float(uptime_file.read().split()[0]))

        reply.complete_info_reply.dattod_uptime_seconds = \
                system_uptime - dattod_uptime

    except IOError as e:
        # Just don't set it if we can't get it
        print e
        pass

    set_block_devices(reply)

    return reply

def handle_connection(connection):
    try:
        # receive 4 bytes containing the size of the Request
        length = connection.recv(4)
        length = struct.unpack('!I', length)[0]

        request = Request()
        # Get the data from the network
        data = connection.recv(length)
        # Interpret the data as a Request object
        request.ParseFromString(data)

        # Handle or pass off
        if request.type in PASSOF_LIST:
            reply = make_request_to_dattod(request)
        elif request.type == Request.BASIC_INFO:
            reply = get_basic_info()
        elif request.type == Request.COMPLETE_INFO:
            reply = get_complete_info()
        else:
            reply = Reply()
            reply.type = Reply.ERROR
            reply.error_reply.short_error = "Unexpected request type"

        reply_serialized = reply.SerializeToString()
        # Send size
        connection.send(struct.pack('!I', len(reply_serialized)))
        # Send Reply
        connection.send(reply_serialized)
    finally:
        # Close connection
        connection.close()

class DattoWebListener(object):
    
    def __init__(self, address):
        self.address = address
        self.sock = None

    def listen(self):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.sock.bind(self.address)
        self.sock.listen(3)

    def accept_loop(self):
        while True:
            conn, addr = self.sock.accept()
            print "Connection from :", addr 
            thread = threading.Thread(target=handle_connection, args=(conn,))
            thread.daemon = True
            thread.start()


if __name__ == "__main__":
    listener = DattoWebListener(LISTEN_ADDRESS)
    listener.listen()
    listener.accept_loop()
