#!/usr/bin/env python

# dattocli supports three commands. Each is delegated to the dattod binary
# through a unix socket, and replies are shown on stdout.
import argparse
import sys
import os
import socket
import struct
from start_backup_request_pb2 import StartBackupRequest
from progress_backup_request_pb2 import ProgressBackupRequest
from stop_backup_request_pb2 import StopBackupRequest
from request_pb2 import Request
from string_reply_pb2 import StringReply


IPC_SOCKET_PATH = "/var/datto/dattod_ipc"

def startbackup(args):
    request = Request()
    request.type = Request.START_BACKUP
    request.start_backup_request.type = args.backup_type
    request.start_backup_request.block_path = args.block_device
    request.start_backup_request.destination_host = args.destination_host
    request.start_backup_request.destination_port = args.destination_port
    return request

def stopbackup(args):
    request = Request()
    request.type = Request.STOP_BACKUP
    request.stop_backup_request.block_path = args.block_device
    return request

def progress(args):
    request = Request()
    request.type = Request.PROGRESS
    request.stop_backup_request.block_path = args.block_device
    return request

# While arg/optparse were tempting, they seem like overkill for our purposes
def parse_args():

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(help="sub-command help")

    start_parser = subparsers.add_parser('startbackup')
    start_parser.set_defaults(func=startbackup)

    start_parser.add_argument('block_device', help="Block device to backup") 

    start_group = start_parser.add_mutually_exclusive_group(required=True)
    start_group.add_argument('-f', '--full', dest="backup_type",
                             action="store_const",
                             const=StartBackupRequest.FULL_BACKUP,
                             help="Do an incremental backup")
    start_group.add_argument('-i', '--incremental', dest="backup_type",
                             action="store_const",
                             const=StartBackupRequest.INCREMENTAL_BACKUP,
                             help="Do an incremental backup")

    start_parser.add_argument('destination_host',
                              help="Destination NBD server hostname")
    start_parser.add_argument('destination_port', type=int,
                              help="Destination NBD server port")

    stop_parser = subparsers.add_parser('stopbackup')
    stop_parser.set_defaults(func=stopbackup)
    stop_parser.add_argument('block_device',
                             help="Block device to stop backing up") 

    parser_progress = subparsers.add_parser('progress')
    stop_parser.set_defaults(func=progress)

    args = parser.parse_args()

    return args.func(args)


# Note that dattocli should not do any validation that block_device is
# actually a block device before passing it off to dattod. dattod should
# perform that validation
def send_to_dattod(message):
    # check if socket path exists, bail (and exit 1) if not
    if not os.path.exists(IPC_SOCKET_PATH):
        print 'Abort: Socket does not exist!'
        exit(1)

    s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    s.connect(IPC_SOCKET_PATH)

    message = message.SerializeToString()
    s.send(struct.pack('!I', len(message))) # send message over the socket
    s.send(message)

    while True: # wait for replies, show them on stdout
        length = s.recv(4) #TODO: is there a sizeof?
        if not length:
            break
        else:
            length = struct.unpack('!I', length)[0]
            data = s.recv(length)
            reply = StringReply()
            reply.ParseFromString(data)
            #print reply.message
            if reply.message == 'DISCONNECT': #TODO: proper disconnect message
               break

    s.close() # when the socket is closed, return    
    pass

if __name__ == "__main__":
    # parse_args should only return if it has a message
    message = parse_args()
    send_to_dattod(message)
